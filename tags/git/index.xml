<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Git on Knowckx's Blog</title><link>https://blog.knowckx.top/tags/git/</link><description>Recent content in Git on Knowckx's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 14 Jan 2026 13:06:51 +0000</lastBuildDate><atom:link href="https://blog.knowckx.top/tags/git/index.xml" rel="self" type="application/rss+xml"/><item><title>Git删除远程分支某次commit的方法</title><link>https://blog.knowckx.top/p/git%E5%88%A0%E9%99%A4%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF%E6%9F%90%E6%AC%A1commit%E7%9A%84%E6%96%B9%E6%B3%95/</link><pubDate>Wed, 18 Sep 2024 08:00:00 +0800</pubDate><guid>https://blog.knowckx.top/p/git%E5%88%A0%E9%99%A4%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF%E6%9F%90%E6%AC%A1commit%E7%9A%84%E6%96%B9%E6%B3%95/</guid><description>&lt;h2 id="懒人阅读版"&gt;懒人阅读版
&lt;/h2&gt;&lt;p&gt;找到你需要去掉的commit的前一次的commitID&lt;/p&gt;
&lt;p&gt;执行&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-shell" data-lang="shell"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;git rebase -i commit_id -X their
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;进入编辑后 在vi里 drop掉不需要的commit&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-shell" data-lang="shell"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;git push -f &lt;span class="c1"&gt;# 覆盖远程分支&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这样远程分支的那次commit就彻底消失了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git push -f&lt;/code&gt;是高危操作 不是特殊时刻不要用&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="原文"&gt;原文
&lt;/h2&gt;&lt;p&gt;最近遇到一个问题，我们的项目代码里，之前把一些&lt;em&gt;密码&lt;/em&gt;配置明文传到了github，&lt;br&gt;
但是公司的安全策略不希望我们在代码里直接留有敏感的账号凭证信息，否则会被扫出来合规性问题。&lt;/p&gt;
&lt;p&gt;按照我同事之前的经历：安全部门扫出来之后就会发邮件给你老板，让你半夜起来马上消掉。&lt;br&gt;
因此产生了一个需求，怎么把github上已提交的敏感信息抹掉呢？&lt;/p&gt;
&lt;p&gt;我调研了下，目前已知有几种方式：&lt;/p&gt;
&lt;h3 id="通过git-revert-commit_id来实现"&gt;通过git revert commit_id来实现
&lt;/h3&gt;&lt;p&gt;git revert 可以撤销某次操作，他是通过提交一次新的commit来回滚之前的一次commit的内容，
大部分情况下这个功能是够用的。&lt;/p&gt;
&lt;p&gt;不适用我们的场景，因为旧的commit实际上不会消失，在github直接打开旧的commit，还是可以看到对应密码信息，不合规。&lt;/p&gt;
&lt;h3 id="通过git-reset-hard-commit_id"&gt;通过git reset &amp;ndash;hard commit_id
&lt;/h3&gt;&lt;p&gt;直接重置到密码提交前的那一次commit，然后&lt;code&gt;git push -f&lt;/code&gt;重置分支&lt;/p&gt;
&lt;p&gt;这样做的前提条件是需要提交密码的那一次commit是最近发生的，&lt;br&gt;
不然就需要手动把后面的历史commit都补回来，工作量很大&lt;/p&gt;
&lt;h3 id="通过git-rebase--i-来实现丢弃一个commit"&gt;通过git rebase -i 来实现丢弃一个commit
&lt;/h3&gt;&lt;p&gt;这是今天发现的解决方案，有点类似于以前git合并多个commit的操作。&lt;br&gt;
下面说下流程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;找到你需要丢弃的commit_id
在我的例子里，我在&lt;code&gt;bdfb32a&lt;/code&gt;这次提交里提交了密码&lt;br&gt;
这次commit的前一次是&lt;code&gt;0119c21&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以执行&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-shell" data-lang="shell"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;git rebase -i 0119c21 -X their
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;解释:&lt;br&gt;
-i 进入交互模式&lt;br&gt;
-X their 方便后续的commit自动合并，不然你需要手动操作冲突。&lt;/p&gt;
&lt;ol start="2"&gt;
&lt;li&gt;这时进入了vi的编辑界面，此时git会把commit_id之后发生的commit列出来，&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们按i进入编辑，手动把不需要的那个commit &lt;code&gt;bdfb32a&lt;/code&gt;前面的&lt;code&gt;pick&lt;/code&gt;改成&lt;code&gt;drop&lt;/code&gt;.&lt;/p&gt;
&lt;ol start="3"&gt;
&lt;li&gt;然后vi和rebase的基本操作：&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;esc, :wd
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;git add .
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;git rebase --continue
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ol start="4"&gt;
&lt;li&gt;手动push 覆盖远程分支&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;此时你通过查看历史，比如&lt;code&gt;git log -10&lt;/code&gt;&lt;br&gt;
应该可以看到commit的历史已经改变了，&lt;code&gt;bdfb32a&lt;/code&gt;已经彻底消失了(被丢弃)。&lt;/p&gt;
&lt;p&gt;执行&lt;code&gt;git push -f&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;再去github看一下&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0119c21&lt;/code&gt;之后的这次&lt;code&gt;bdfb32a&lt;/code&gt;已经抹除。&lt;/p&gt;
&lt;p&gt;收工~！&lt;/p&gt;</description></item><item><title>git rebase有个坑</title><link>https://blog.knowckx.top/p/git-rebase-push-rejected/</link><pubDate>Fri, 28 Apr 2023 08:00:00 +0800</pubDate><guid>https://blog.knowckx.top/p/git-rebase-push-rejected/</guid><description>&lt;h3 id="场景"&gt;场景:
&lt;/h3&gt;&lt;p&gt;这是一个Git在日常工作中非常核心的问题，很多工作了多年的同事也没吃透这个问题，没有正确理解&lt;code&gt;merge&lt;/code&gt;和&lt;code&gt;rebase&lt;/code&gt;的区别。 &lt;br&gt;
今天我花时间自己做了几个实验，也算是明白了，记录一下。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;常见场景&lt;/strong&gt;&lt;br&gt;
自己&lt;code&gt;fork&lt;/code&gt;了一个分支进行一个特性功能的开发，开发完了准备发起了&lt;code&gt;PR&lt;/code&gt;&lt;br&gt;
结果发现在自己开发期间，&lt;code&gt;主分支&lt;/code&gt;有了几次新的合入。&lt;/p&gt;
&lt;p&gt;这时候你想把主分支的改动更新到本地。&lt;br&gt;
为了让合并的历史更&lt;strong&gt;优雅&lt;/strong&gt;, 此时执行了&lt;code&gt;git reabase upstream main&lt;/code&gt;&lt;br&gt;
此时问题来了，你会发现你的这个本地的分支&lt;code&gt;push&lt;/code&gt;不上去了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原因&lt;/strong&gt;&lt;br&gt;
简单来说，&lt;code&gt;git rebase&lt;/code&gt; 操作修改了你本地分支的提交历史，使其与远程分支的提交历史产生了分歧。&lt;br&gt;
Git为了保护远程分支不被意外覆盖，会拒绝你的&lt;code&gt;non-fast-forward&lt;/code&gt;推送。&lt;/p&gt;
&lt;h3 id="正常的-git-push-流程"&gt;正常的 git push 流程
&lt;/h3&gt;&lt;p&gt;在没有冲突的情况下，&lt;code&gt;git push&lt;/code&gt; 遵循一个&lt;strong&gt;快进式&lt;/strong&gt;（Fast-forward）的原则。&lt;/p&gt;
&lt;p&gt;远程分支 (origin/my-feature) 的历史是:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A &amp;mdash; B&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你拉取了代码，在本地 (my-feature) 继续工作，增加了提交 C:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A &amp;mdash; B &amp;mdash; C&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当你执行 &lt;code&gt;git push&lt;/code&gt; 时，Git会比较你的本地分支和远程分支。&lt;br&gt;
它发现你的本地分支只是在远程分支&lt;code&gt;提交B&lt;/code&gt;的基础上加了一个&lt;code&gt;提交C&lt;/code&gt;&lt;br&gt;
于是它会执行一次&lt;strong&gt;Fast-forward&lt;/strong&gt;，直接把远程分支的指针移动到&lt;code&gt;C&lt;/code&gt;。&lt;br&gt;
推送后，远程分支也变成了:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A &amp;mdash; B &amp;mdash; C&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个过程是最常见的，也是安全的，因为它只是在原有历史的末尾继续添加新内容，不会丢失任何东西。&lt;/p&gt;
&lt;h3 id="git-rebase-的流程解释"&gt;git rebase 的流程解释
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;rebase&lt;/code&gt; 的中文意思是&lt;strong&gt;变基&lt;/strong&gt;，它的核心作用是&lt;code&gt;重写提交历史&lt;/code&gt;，让分支历史变成一条直线更美观。&lt;/p&gt;
&lt;p&gt;假设你从 &lt;code&gt;main&lt;/code&gt; 分支切出了 &lt;code&gt;my-feature&lt;/code&gt; 分支并开始工作。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;main 分支: A &amp;mdash; B&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;my-feature 分支: A &amp;mdash; B &amp;mdash; C (你增加了提交 C)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在你工作的时候，你的同事向 &lt;code&gt;main&lt;/code&gt; 分支推送了一个新的提交 D。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;main 分支现在是: A &amp;mdash; B &amp;mdash; D&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;你的 my-feature 分支还是: A &amp;mdash; B &amp;mdash; C&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;此时，你的分支和 main 分支从提交 B 开始&lt;strong&gt;分叉&lt;/strong&gt;了。&lt;br&gt;
为了让你的分支包含 main 的最新更改，你执行了 &lt;code&gt;git rebase main&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;rebase 会做以下事情：&lt;br&gt;
a. 暂时&amp;quot;&lt;strong&gt;收起&lt;/strong&gt;&amp;ldquo;你在 &lt;code&gt;my-feature&lt;/code&gt; 分支上的独有提交（也就是 &lt;code&gt;C&lt;/code&gt;）。&lt;br&gt;
b. 从与 &lt;code&gt;main&lt;/code&gt; 分支最后的共同提交B开始，抓取新增加的改动 &lt;code&gt;D&lt;/code&gt; 到 &lt;code&gt;my-feature&lt;/code&gt; 分支&lt;br&gt;
c. 将刚才&lt;strong&gt;收起&lt;/strong&gt;的提交 &lt;code&gt;C&lt;/code&gt; 在新的起点 &lt;code&gt;D&lt;/code&gt; 上重新应用一遍。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;此时my-feature 分支变成了: A &amp;mdash; B &amp;mdash; D &amp;mdash; 收起的C&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关键点来了：&lt;br&gt;
重新应用的 &lt;code&gt;C&lt;/code&gt; 这个提交，虽然代码内容没变，但它的&lt;code&gt;父提交&lt;/code&gt;从原来的 &lt;code&gt;B&lt;/code&gt; 变成了现在的 &lt;code&gt;D&lt;/code&gt;。&lt;br&gt;
在Git中，一个提交的唯一标识&lt;code&gt;SHA-1哈希值&lt;/code&gt;是由其内容、作者、时间戳、以及&lt;strong&gt;父提交&lt;/strong&gt;等信息共同决定的。&lt;br&gt;
&lt;strong&gt;父提交&lt;/strong&gt;变了，哈希值就会变！所以新的 &lt;code&gt;C&lt;/code&gt; 对应的hashID，和原来的 &lt;code&gt;C&lt;/code&gt; 是不同的 &lt;br&gt;
你实际上得到一个内容完全一样，但是hashID变了的提交 &lt;code&gt;C'&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;所以Rebase之后，my-feature 分支历史: A &amp;mdash; B &amp;mdash; D &amp;mdash; C'&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="为什么-rebase-后-push-会失败"&gt;为什么 rebase 后 push 会失败？
&lt;/h3&gt;&lt;p&gt;现在，我们来比较一下 &lt;code&gt;rebase&lt;/code&gt; 后的本地分支和远程分支&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本地 my-feature 分支: A &amp;mdash; B &amp;mdash; D &amp;mdash; C'&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;远程 origin/my-feature 分支: A &amp;mdash; B &amp;mdash; C&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当你执行 &lt;code&gt;git push&lt;/code&gt; 时，Git会进行比较，然后它会发现：
这两个分支从共同的祖先 B 开始就分道扬镳了。本地 &lt;code&gt;my-feature&lt;/code&gt;的历史里并没有包含远程的 &lt;code&gt;C&lt;/code&gt; 提交。&lt;br&gt;
如果接受推送，远程的 &lt;code&gt;C&lt;/code&gt; 提交就会丢失，这太危险了！所以拒绝这次推送。&lt;/p&gt;
&lt;p&gt;这就是你看到的 (&lt;code&gt;non-fast-forward&lt;/code&gt;) 错误。&lt;br&gt;
Git通过这个机制，防止你无意中覆盖掉远程仓库可能存在的、你本地没有的提交。&lt;/p&gt;
&lt;h3 id="解决方式"&gt;解决方式:
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;方式1&lt;/strong&gt; 在使用&lt;code&gt;fork&lt;/code&gt;后的分支开发后，使用&lt;code&gt;merge&lt;/code&gt;策略来合并改动。&lt;br&gt;
缺点: commit的历史线会比较混乱，不好看&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方式2&lt;/strong&gt; 使用&lt;code&gt;reabse&lt;/code&gt;后，搭配&lt;code&gt;push -f&lt;/code&gt;来强行更新&lt;strong&gt;远程自己的分支&lt;/strong&gt;，&lt;br&gt;
Commit ID的历史会是一条直线，就像前面例子的&lt;code&gt;A --- B --- D --- C'&lt;/code&gt;，很会&lt;strong&gt;优雅&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id="解释push--f-的作用和风险"&gt;解释push -f 的作用和风险
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;git push --force&lt;/code&gt; (或简写 &lt;code&gt;-f&lt;/code&gt;) 就是你给Git下的一个强制命令，意思是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“别管什么快进不快进了，也别管远程分支上有什么。我push给你的这个版本就是最终版本，你就用我这个版本去覆盖”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;执行 &lt;code&gt;git push -f&lt;/code&gt; 后，&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;远程的 origin/my-feature 被强制更新为: A &amp;mdash; B &amp;mdash; D &amp;mdash; C'&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;git push -f&lt;/code&gt; 是一个比较危险的操作，千万不要向公共分支（如 main, develop）执行 &lt;code&gt;push -f&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;对于自己的特性分支执行是没有问题的。通常，一个特性分支只有你一个人在开发。&lt;br&gt;
在你准备合并到主分支之前，用 rebase 来保持分支的整洁，然后用 &lt;code&gt;push -f&lt;/code&gt; 更新你自己的远程分支，这是非常常见的做法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;更安全的选择：&lt;code&gt;git push --force-with-lease&lt;/code&gt;&lt;/strong&gt;&lt;br&gt;
它在强制推送前会增加一个检查：只有当远程分支的状态和你本地最后一次拉取时一模一样，它才会执行强制推送。&lt;/p&gt;
&lt;p&gt;换句话说，如果在你执行 rebase 到你准备 push 的这段时间里，有其他人也向这个远程分支推送了新的提交，
&lt;code&gt;--force-with-lease&lt;/code&gt; 就会失败。这可以防止你覆盖掉别人在你不知情的情况下推送的工作。
日常工作中，推荐使用 &lt;code&gt;git push --force-with-lease&lt;/code&gt; 代替 &lt;code&gt;git push -f&lt;/code&gt;。&lt;/p&gt;</description></item></channel></rss>